The Mission: Make Voting Frictionless

Today started with a simple goal: make it dead simple for anyone to vote on AI-generated artwork. No passwords to remember, no complicated formsâ€”just an email address and you're in.

Sounds easy, right? Well...

Act I: Passwordless Authentication (Or: How I Learned to Love Magic Links)

The first challenge was implementing passwordless authentication using Supabase. The idea was beautiful in its simplicity:

1. User enters their email
2. They get a magic link
3. Click the link, boomâ€”authenticated

But as with all "simple" ideas in software development, the devil was in the details.

The Auth Flow Refactor

I had to completely overhaul the authentication system. Here's what changed:

Before:

// Traditional password-based auth
const { data, error } = await supabase.auth.signInWithPassword({
  email,
  password
});

After:

// Magic link authentication
const { error } = await supabase.auth.signInWithOtp({
  email,
  options: {
    emailRedirectTo: `${window.location.origin}/auth/callback`
  }
});

The Callback Dance

The tricky part? Handling the magic link callback. When users click the link in their email, they're redirected back with a code parameter that needs to be exchanged for a session.

I created a new route at src/app/auth/callback/route.ts that:

1. Extracts the code from the URL
2. Exchanges it for a session using exchangeCodeForSession()
3. Creates a user record in our public_users table if needed
4. Redirects them to the contest page

const { data: { user }, error } = await supabase.auth.exchangeCodeForSession(code);

if (!error && user) {
  // Check if user exists in our public_users table
  const { data: publicUser } = await supabase
    .from('public_users')
    .select('*')
    .eq('id', user.id)
    .single();

  if (!publicUser) {
    // Create user record
    await supabase.from('public_users').insert({
      id: user.id,
      email: user.email!,
      name: user.user_metadata?.name || null,
    });
  }
}

Act II: The Great Schema Catastrophe

Just when I thought we were making progress, I hit a wall. A TypeScript-shaped wall.

The Admin Schema Illusion

Initially, I thought I was being clever. "Let's use a separate admin schema for all the blog and admin tables," I thought. "It'll be more organized!"

So I spent hours updating 13 files with references like:

supabase.from('admin.blog_posts')
supabase.from('admin.blog_categories')

The TypeScript Rebellion

Then came the build:

Type error: Argument of type '"admin.blog_posts"' is not assignable to parameter of type 'TableName'

58 errors. Fifty. Eight.

Turns out, Supabase's TypeScript client doesn't support schema-qualified table names. At all. The from() method expects just the table name, not schema.table.

The Pivot: RLS to the Rescue

Here's where I had to make a crucial architectural decision. Instead of fighting TypeScript, I embraced Row Level Security (RLS).

The revelation: You don't need separate schemas when you have RLS policies.

I reverted all the changes (thank god for scripts):

// scripts/revert-admin-prefix.js
const replacements = [
  { from: /\.from\(['"`]admin\.blog_posts['"`]\)/g, to: ".from('blog_posts')" },
  { from: /\.from\(['"`]admin\.blog_categories['"`]\)/g, to: ".from('blog_categories')" },
  // ... and so on
];

Result:
â€¢ 13 files updated
â€¢ 58 changes reverted
â€¢ All tables in public schema
â€¢ Security handled by RLS policies

-- RLS ensures only admins can write
CREATE POLICY "Admin write access"
ON blog_posts FOR INSERT
TO authenticated
USING (is_admin(auth.uid()));

-- Public can read published posts
CREATE POLICY "Public read published"
ON blog_posts FOR SELECT
USING (status = 'published');

Act III: TypeScript Whack-a-Mole

With the schema issues resolved, I still had a handful of TypeScript errors to squash:

Error #1: The Contest Type Mismatch

// src/app/contest/page.tsx
// Before: Redefining everything
interface Contest {
  id: string;
  title: string;
  // ... 10 more fields
}

// After: Extend the generated type
interface Contest extends ContestRow {
  time_remaining?: string; // Just add what we need
}

Error #2: The JSX Namespace Mystery

// Before: TypeScript couldn't find JSX
const HeadingTag = `h${level}` as keyof JSX.IntrinsicElements;

// After: Explicit union type
const HeadingTag = `h${level}` as 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';

Error #3: The Heading Classes Index

// Before: TypeScript feared the unknown
const className = headingClasses[node.attrs.level];

// After: Proper Record type with fallback
const headingClasses: Record<number, string> = {
  1: 'text-3xl font-bold text-white mb-6 mt-8',
  2: 'text-2xl font-bold text-white mb-4 mt-6',
  3: 'text-xl font-semibold text-white mb-3 mt-4',
};
const className = headingClasses[node.attrs.level as number] || 'text-lg';

Act IV: Environment Configuration Hell

Deploying to production meant dealing with three different environments:

1. Local Development: http://localhost:3000
2. Production: https://olliedoesis.dev
3. Vercel Previews: https://ai-art-arena-*.vercel.app

I created an environment detection utility at src/lib/env.ts:

export function getBaseUrl() {
  // Client-side: use window.location
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }

  // Server-side production: use Vercel URL
  if (process.env.VERCEL_URL && isProduction()) {
    return `https://${process.env.VERCEL_URL}`;
  }

  // Fallback to configured URL or localhost
  if (process.env.NEXT_PUBLIC_SITE_URL) {
    return process.env.NEXT_PUBLIC_SITE_URL;
  }

  return 'http://localhost:3000';
}

The Port 3000 Battle

Right before launch, disaster struck: port 3000 was in use.

Port 3000 is in use, trying 3001 instead

Multiple Node.js processes were running from previous dev sessions. The fix:

# Kill all Node processes (Windows)
taskkill /F /IM node.exe

# Remove stale lock file
rm .next/dev/lock

# Start fresh
npm run dev

Victory: Site back on localhost:3000 where it belongs.

The Final Push: Git Commit & Deploy

After hours of refactoring, error-fixing, and troubleshooting, it all came down to this:

git add .
git commit -m "Fix blog schema and resolve all TypeScript build errors

- Clarified schema approach (public schema + RLS)
- Updated 13 files to remove admin. prefix
- Fixed TypeScript build errors
- Build now compiles successfully

ðŸ¤– Generated with Claude Code
Co-Authored-By: Claude <noreply@anthropic.com>"

git push origin main

âœ“ Compiled successfully in 51s
âœ“ No TypeScript errors
âœ“ Ready for deployment

Lessons Learned

1. Trust the Framework
Supabase uses RLS for a reason. Don't fight it with custom schema separation unless you have a very specific need.

2. Generated Types Are Your Friend
When using Supabase with TypeScript, trust the generated types. Extend them, don't redefine them.

3. Environment Detection Matters
In a world of serverless deployments and preview URLs, you need smart environment detection from day one.

4. Kill Your Processes
Always clean up dev processes. That port conflict at 4 PM will haunt you.

5. Document Everything
I created these guides during development:
â€¢ COMPLETE-SETUP-GUIDE.md
â€¢ AUTH-SETUP.md
â€¢ ENVIRONMENT-SETUP.md
â€¢ SCHEMA-FIX-COMPLETE.md

Future me will thank present me.

The Tech Stack

For those keeping score at home:

â€¢ Framework: Next.js 16.0.3 (App Router + Turbopack)
â€¢ Database: Supabase (PostgreSQL)
â€¢ Auth: Supabase Auth (Magic Links)
â€¢ Deployment: Vercel
â€¢ Language: TypeScript
â€¢ Styling: Tailwind CSS

What's Next?

The site is live at olliedoesis.dev, but the work never stops:

1. âœ… Passwordless authentication
2. âœ… Database schema with RLS
3. âœ… TypeScript errors resolved
4. âœ… Multi-environment support
5. ðŸ”² Supabase email confirmation disabled
6. ðŸ”² Production auth redirect URLs configured
7. ðŸ”² Blog schema applied to production database
8. ðŸ”² First community vote!

The Moral of the Story

Software development is rarely a straight line from problem to solution. It's more like:

Problem â†’ Solution â†’ Compile Error â†’ Different Solution â†’ Schema Error â†’ Complete Refactor â†’ 58 TypeScript Errors â†’ Revert Everything â†’ RLS Epiphany â†’ Port Conflict â†’ Success! ðŸŽ‰

But that's what makes it fun. Every error is a chance to learn something new, every refactor makes the codebase cleaner, and every successful deploy feels like a small victory.

Today, we launched AI Art Arena with passwordless authentication, a clean database architecture, and zero TypeScript errors.

Tomorrow? We'll probably break something new. And that's okay.

---

Want to vote on AI-generated art? Check out AI Art Arena at olliedoesis.dev and join the community!

Follow the journey: I'll be documenting more development stories right here on the blog.

Questions? Thoughts? Found a bug? Let me know in the comments below!